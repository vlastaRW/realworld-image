
#pragma once

#include <boost/spirit.hpp>
using namespace boost::spirit;
#include <ImageClipboardUtils.h>


struct CFillStyleDataPattern
{
	MIDL_INTERFACE("95610C13-FAF9-4B97-864F-A8F45508C1D7")
	ISharedStateToolData : public ISharedState
	{
	public:
		STDMETHOD_(CFillStyleDataPattern const*, InternalData)() = 0;
	};

	CFillStyleDataPattern() : nIndex(0), bStock(true)
	{
		tColor1.fR = tColor1.fG = tColor1.fB = 0.0f;
		tColor1.fA = tColor2.fR = tColor2.fG = tColor2.fB = tColor2.fA = 1.0f;
	}
	HRESULT FromString(BSTR a_bstr)
	{
		if (a_bstr)
		{
			LPCWSTR psz1 = wcschr(a_bstr, L'|');
			LPCWSTR psz2 = psz1 ? wcschr(psz1+1, L'|') : NULL;
			LPCWSTR psz3 = psz2 ? wcschr(psz2+1, L'|') : NULL;
			if (psz1 && psz2 && psz3)
			{
				bStock = wcsncmp(a_bstr, L"CUSTOM", 6);
				int i = nIndex;
				if (1 == swscanf(psz1+1, L"%i", &i))
					nIndex = i;
				strPath.assign(psz2+1, psz3);
				TColor t1 = tColor1;
				TColor t2 = tColor2;
				if (8 == swscanf(psz3+1, L"%i,%f,%f,%f,%f,%f,%f,%f,%f", &t1.fR, &t1.fG, &t1.fB, &t1.fA, &t2.fR, &t2.fG, &t2.fB, &t2.fA))
				{
					tColor1 = t1;
					tColor2 = t2;
				}
			}
			else if (psz1 && psz2)
			{
				bStock = wcsncmp(a_bstr, L"CUSTOM", 6);
				int i = nIndex;
				if (1 == swscanf(psz1+1, L"%i", &i))
					nIndex = i;
				strPath = psz2+1;
			}
			else
			{
				int i = nIndex;
				if (1 == swscanf(a_bstr, L"%i", &i))
				{
					bStock = true;
					strPath.clear();
					nIndex = i;
				}
			}
		}
		return S_OK;
	}
	HRESULT ToString(BSTR* a_pbstr)
	{
		wchar_t szTmp[MAX_PATH+100];
		swprintf(szTmp, L"%s|%i|%s|%g,%g,%g,%g,%g,%g,%g,%g", bStock ? L"STOCK" : L"CUSTOM", int(nIndex), strPath.c_str(), tColor1.fR, tColor1.fG, tColor1.fB, tColor1.fA, tColor2.fR, tColor2.fG, tColor2.fB, tColor2.fA);
		*a_pbstr = SysAllocString(szTmp);
		return S_OK;
	}
	bool operator!=(CFillStyleDataPattern const& a_cData) const
	{
		return bStock != a_cData.bStock || nIndex != a_cData.nIndex || strPath != a_cData.strPath;
	}

	bool bStock;
	size_t nIndex;
	std::wstring strPath;
	TColor tColor1;
	TColor tColor2;
};

extern __declspec(selectany) BYTE const g_aDiagonalSmall[] =
{
	0x3f, 0x00, 0x3f, 0xeb,
	0x00, 0x3f, 0xeb, 0x3f,
	0x3f, 0xeb, 0x3f, 0x00,
	0xeb, 0x3f, 0x00, 0x3f,
};

extern __declspec(selectany) BYTE const g_aDiagonalMedium[] =
{
	0x90, 0x00, 0x00, 0x00, 0x90, 0xff,
	0x00, 0x00, 0x00, 0x90, 0xff, 0x90,
	0x00, 0x00, 0x90, 0xff, 0x90, 0x00,
	0x00, 0x90, 0xff, 0x90, 0x00, 0x00,
	0x90, 0xff, 0x90, 0x00, 0x00, 0x00,
	0xff, 0x90, 0x00, 0x00, 0x00, 0x90,
};

extern __declspec(selectany) BYTE const g_aBrick[] =
{
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
	0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00,
};

extern __declspec(selectany) BYTE const g_aConfetti[] =
{
	0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00,
	0x00, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00,
	0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff,
	0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff,
	0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
};

extern __declspec(selectany) BYTE const g_aCheckboard[] =
{
	0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
	0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
	0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
	0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
	0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
	0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
	0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff,
};

extern __declspec(selectany) BYTE const g_aSolidGrid[] =
{
	0xff, 0xff, 0xff, 0xff, 0xff,
	0xff, 0x00, 0x00, 0x00, 0x00,
	0xff, 0x00, 0x00, 0x00, 0x00,
	0xff, 0x00, 0x00, 0x00, 0x00,
	0xff, 0x00, 0x00, 0x00, 0x00,
};

extern __declspec(selectany) BYTE const g_aDottedGrid[] =
{
	0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00,
	0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00,
	0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff, 0x00, 0xff,
	0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00,
	0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00,
};

extern __declspec(selectany) BYTE const g_aDiagonalCross[] =
{
	0xff, 0x90, 0x00, 0x00, 0x00, 0x00, 0x90, 0xff,
	0x90, 0xff, 0x90, 0x00, 0x00, 0x90, 0xff, 0x90,
	0x00, 0x90, 0xff, 0x90, 0x90, 0xff, 0x90, 0x00,
	0x00, 0x00, 0x90, 0xff, 0xff, 0x90, 0x00, 0x00,
	0x00, 0x00, 0x90, 0xff, 0xff, 0x90, 0x00, 0x00,
	0x00, 0x90, 0xff, 0x90, 0x90, 0xff, 0x90, 0x00,
	0x90, 0xff, 0x90, 0x00, 0x00, 0x90, 0xff, 0x90,
	0xff, 0x90, 0x00, 0x00, 0x00, 0x00, 0x90, 0xff,
};

extern __declspec(selectany) BYTE const g_aWave[] =
{
	0x00, 0x8c, 0xff, 0xee, 0x50, 0x00, 0x00, 0x4f, 0x00, 0x00,
	0x4f, 0xff, 0x9b, 0xc9, 0xfe, 0x85, 0xa1, 0xff, 0x4e, 0x00,
	0x00, 0x4f, 0x00, 0x08, 0xa1, 0xff, 0xfd, 0x80, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x4f, 0x00, 0x00, 0x00, 0x8c, 0xff, 0xee, 0x50,
	0x85, 0xa1, 0xff, 0x4e, 0x00, 0x4f, 0xff, 0x9b, 0xc9, 0xfe,
	0xff, 0xfd, 0x80, 0x00, 0x00, 0x00, 0x4f, 0x00, 0x08, 0xa1,
	0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

extern __declspec(selectany) BYTE const g_aEveryOther[] =
{
	0xff, 0x00,
	0x00, 0xff,
};

extern __declspec(selectany) BYTE const g_aWires[] =
{
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 
	0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 
	0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 
	0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 
	0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 
	0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 
	0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
};

extern __declspec(selectany) BYTE const g_aChips[] =
{
	0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 
	0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 
	0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 
	0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 
	0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 
	0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 
};

extern __declspec(selectany) BYTE const g_aDot[] =
{
	0x00, 0x4b, 0xcc, 0xf4, 0xcc, 0x4b, 0x00, 0x00, 
	0x4c, 0xff, 0xff, 0xff, 0xff, 0xff, 0x4b, 0x00, 
	0xcc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xcc, 0x00, 
	0xf4, 0xff, 0xff, 0xff, 0xff, 0xff, 0xf3, 0x00, 
	0xcc, 0xff, 0xff, 0xff, 0xff, 0xff, 0xcc, 0x00, 
	0x4b, 0xff, 0xff, 0xff, 0xff, 0xff, 0x4a, 0x00, 
	0x00, 0x4b, 0xcc, 0xf3, 0xcc, 0x4b, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
};

extern __declspec(selectany) BYTE const g_aPavement[] =
{
	0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x3f, 0xeb, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xeb, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x3f, 0xeb, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xeb, 0x3f, 0x00, 0x00, 0x00, 0x00, 
	0xff, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 
	0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 
	0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 
	0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 
	0xff, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 
	0x3f, 0xeb, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xeb, 0x3f, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x3f, 0xeb, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x3f, 0xeb, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x3f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	//0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	//0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 
	//0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 
	//0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 
	//0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 
	//0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 
	//0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 
	//0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 
	//0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 
	//0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 
	//0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	//0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	//0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	//0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
};

extern __declspec(selectany) struct SPattern { ULONG nX, nY; BYTE const* pP; OLECHAR const* pName; } const g_aPatterns[] =
{
	{4, 4, g_aDiagonalSmall, L"Diagonal small"},
	{6, 6, g_aDiagonalMedium, L"Diagonal medium"},
	{8, 8, g_aBrick, L"Brick"},
	{8, 8, g_aConfetti, L"Confetti"},
	{8, 8, g_aCheckboard, L"Checkboard"},
	{5, 5, g_aSolidGrid, L"Solid grid"},
	{10, 10, g_aDottedGrid, L"Dotted grid"},
	{8, 8, g_aDiagonalCross, L"Diagonal cross"},
	//{8, 8, g_aConfetti, _T("Shingle")},
	{10, 8, g_aWave, L"Wave"},
	{2, 2, g_aEveryOther, L"Every other"},
	{15, 15, g_aWires, L"Hammock"},
	{16, 16, g_aChips, L"Chips"},
	{8, 8, g_aDot, L"Dots"},
	{16, 16, g_aPavement, L"Pavement"},
};

#include "FillStylePatternDlg.h"


class CFillStylePattern :
	public CComObjectRootEx<CComMultiThreadModel>,
	public IRasterImageBrush,
	public IRasterImageEditToolScripting
{
public:
	CFillStylePattern()
	{
	}

	BEGIN_COM_MAP(CFillStylePattern)
		COM_INTERFACE_ENTRY(IRasterImageBrush)
		COM_INTERFACE_ENTRY(IRasterImageEditToolScripting)
	END_COM_MAP()

	// IRasterImageBrush methods
public:
	STDMETHOD(Init)(IRasterImageBrushOwner* a_pOwner)
	{
		m_pOwner = a_pOwner;
		return S_OK;
	}
	STDMETHOD(SetShapeBounds)(TPixelCoords const* UNREF(a_pCenter), float UNREF(a_fSizeX), float UNREF(a_fSizeY), float UNREF(a_fAngle))
	{
		return E_NOTIMPL;
	}
	STDMETHOD(SetState)(ISharedState* a_pState)
	{
		CComQIPtr<CFillStyleDataPattern::ISharedStateToolData> pData(a_pState);
		if (pData)
		{
			m_cData = *(pData->InternalData());
			if (m_pOwner)
				m_pOwner->RectangleChanged(NULL);
		}
		return S_OK;
	}
	STDMETHOD(GetState)(ISharedState** a_ppState)
	{
		try
		{
			*a_ppState = NULL;
			CComObject<CSharedStateToolData>* pNew = NULL;
			CComObject<CSharedStateToolData>::CreateInstance(&pNew);
			CComPtr<ISharedState> pTmp = pNew;
			if (pNew->Init(m_cData))
			{
				m_pOwner->SetBrushState(pTmp);
			}
			*a_ppState = pTmp.Detach();
			return S_OK;
		}
		catch (...)
		{
			return a_ppState ? E_UNEXPECTED : E_POINTER;
		}
	}
	STDMETHOD(NeedsPrepareShape)()
	{
		return S_FALSE;
	}
	STDMETHOD(PrepareShape)(RECT const* a_pBounds, ULONG a_nPaths, TRWPolygon const* a_pPaths)
	{
		return E_NOTIMPL;
	}
	STDMETHOD(IsSolid)(RECT const* UNREF(a_pRect))
	{
		return S_FALSE;
	}
	STDMETHOD(GetBrushTile)(ULONG a_nX, ULONG a_nY, ULONG a_nSizeX, ULONG a_nSizeY, float a_fGamma, ULONG a_nStride, TRasterImagePixel* a_pBuffer)
	{
		if (m_cData.bStock)
		{
			SPattern const* pPat = g_aPatterns+m_cData.nIndex;
			CAutoVectorPtr<TRasterImagePixel> cPat(new TRasterImagePixel[pPat->nX*pPat->nY]);
			TColor const tC2 = m_cData.tColor1;
			TColor const tC1 = m_cData.tColor2;
			float fGammaInv = 1.0f/a_fGamma;
			for (LONG n = pPat->nX*pPat->nY-1; n >= 0; --n)
			{
				TRasterImagePixel& t = cPat[n];
				ULONG const i = pPat->pP[n];
				ULONG const i2 = 255-i;
				float const fA = tC1.fA*i2 + tC2.fA*i;
				BYTE bA = fA + 0.5f;
				if (bA)
				{
					float const fIA = 255.0f/fA;
					float const fA1 = tC1.fA*i2/255.0f;
					float const fA2 = tC2.fA*i/255.0f;
					t.bR = powf((tC1.fR*fA1 + tC2.fR*fA2)*fIA, fGammaInv)*255.0f+0.5f;
					t.bG = powf((tC1.fG*fA1 + tC2.fG*fA2)*fIA, fGammaInv)*255.0f+0.5f;
					t.bB = powf((tC1.fB*fA1 + tC2.fB*fA2)*fIA, fGammaInv)*255.0f+0.5f;
					t.bA = bA;
				}
				else
				{
					static TRasterImagePixel const t0 = {0, 0, 0, 0};
					t = t0;
				}
			}
			for (ULONG y = 0; y < a_nSizeY; ++y)
			{
				ULONG const nDY = pPat->nX*((y+a_nY)%pPat->nY);
				for (ULONG x = 0; x < a_nSizeX; ++x)
				{
					*(a_pBuffer++) = cPat[((x+a_nX)%pPat->nX)+nDY]; // TODO: optimize
				}
				a_pBuffer += a_nStride-a_nSizeX;
			}
		}
		else
		{
			{
				ObjectLock cLock(this);
				if (m_strPatPath != m_cData.strPath)
				{
					m_strPatPath = m_cData.strPath;
					m_nPatSizeX = m_nPatSizeY = 0;
					m_pPatData.Free();
					try
					{
						if (m_cData.strPath.substr(0, 10) == L"clipboard:")
						{
							TImageSize tSize = {0, 0};
							GetClipboardImage(GetForegroundWindow(), tSize, m_pPatData);
							m_nPatSizeX = tSize.nX;
							m_nPatSizeY = tSize.nY;
						}
						else
						{
							CComPtr<IInputManager> pInMgr;
							RWCoCreateInstance(pInMgr, __uuidof(InputManager));
							CComPtr<IEnumUnknowns> pBuilders;
							pInMgr->GetCompatibleBuilders(1, &__uuidof(IDocumentImage), &pBuilders);
							CComPtr<IDocument> pDoc;
							pInMgr->DocumentCreateEx(pBuilders, CStorageFilter(m_cData.strPath.c_str()), NULL, &pDoc);
							CComPtr<IDocumentImage> pImage;
							pDoc->QueryFeatureInterface(__uuidof(IDocumentImage), reinterpret_cast<void**>(&pImage));
							TImageSize tSize;
							pImage->CanvasGet(&tSize, NULL, NULL, NULL, NULL);
							m_nPatSizeX = tSize.nX;
							m_nPatSizeY = tSize.nY;
							m_pPatData.Allocate(m_nPatSizeX*m_nPatSizeY);
							pImage->TileGet(EICIRGBA, NULL, NULL, NULL, m_nPatSizeX*m_nPatSizeY, m_pPatData, NULL, EIRIPreview);
						}
					}
					catch (...)
					{
					}
				}
			}
			if (m_pPatData.m_p)
			{
				for (ULONG y = 0; y < a_nSizeY; ++y)
				{
					ULONG const nDY = m_nPatSizeX*((y+a_nY)%m_nPatSizeY);
					for (ULONG x = 0; x < a_nSizeX; ++x)
					{
						*(a_pBuffer++) = reinterpret_cast<TRasterImagePixel const*>(m_pPatData.m_p)[((x+a_nX)%m_nPatSizeX)+nDY]; // TODO: optimize
					}
					a_pBuffer += a_nStride-a_nSizeX;
				}
			}
			else
			{
				for (ULONG y = 0; y < a_nSizeY; ++y)
				{
					for (ULONG x = 0; x < a_nSizeX; ++x)
					{
						static TRasterImagePixel const t = {0, 0, 0, 255};
						*(a_pBuffer++) = t;
					}
					a_pBuffer += a_nStride-a_nSizeX;
				}
			}
		}
		return S_OK;
	}
	STDMETHOD(AdjustCoordinates)(TPixelCoords* a_pPos, ULONG a_nControlPointIndex)
	{
		return S_OK;
	}
	STDMETHOD(GetControlPointCount)(ULONG* a_pCount)
	{
		try
		{
			*a_pCount = 0;
			return S_OK;
		}
		catch (...)
		{
			return a_pCount ? E_UNEXPECTED : E_POINTER;
		}
	}
	STDMETHOD(GetControlPoint)(ULONG a_nIndex, TPixelCoords* a_pPos, ULONG* a_pClass)
	{
		return E_RW_INDEXOUTOFRANGE;
	}
	STDMETHOD(SetControlPoint)(ULONG a_nIndex, TPixelCoords const* a_pPos, boolean a_bReleased, float a_fPointSize)
	{
		return E_RW_INDEXOUTOFRANGE;
	}
	STDMETHOD(GetControlPointDesc)(ULONG a_nIndex, ILocalizedString** a_ppDescription)
	{
		return E_NOTIMPL;
	}
	STDMETHOD(GetControlLines)(IEditToolControlLines* a_pLines)
	{
		return S_FALSE;
	}

	STDMETHOD(Transform)(TMatrix3x3f const* a_pMatrix)
	{
		return S_FALSE;
	}

	// IRasterImageEditToolScripting
public:
	void Unescape(std::wstring& a_str)
	{
		size_t nLen = a_str.length();
		size_t iD = 0;
		size_t iS = 0;
		while (iS < nLen)
		{
			if (a_str[iS] == L'\\')
				++iS;
			if (iS == nLen)
				break;
			a_str[iD] = a_str[iS];
			++iS;
			++iD;
		}
		if (iD != iS)
			a_str.resize(iD);
	}
	STDMETHOD(FromText)(BSTR a_bstrParams)
	{
		try
		{
			if (a_bstrParams == NULL)
				return S_FALSE;
			CFillStyleDataPattern cData = m_cData;
			std::wstring strPatt;
			rule<scanner<wchar_t*> > cSep = *space_p>>L','>>*space_p;
			bool bParsed = parse(a_bstrParams, a_bstrParams+SysStringLen(a_bstrParams), *space_p>>
					confix_p(L'"', (*c_escape_ch_p)[assign_a(strPatt)], L'"')>>
					(!(
					cSep>>real_p[assign_a(m_cData.tColor1.fR)]>>
					cSep>>real_p[assign_a(m_cData.tColor1.fG)]>>
					cSep>>real_p[assign_a(m_cData.tColor1.fB)]>>
					cSep>>real_p[assign_a(m_cData.tColor1.fA)]>>
					cSep>>real_p[assign_a(m_cData.tColor2.fR)]>>
					cSep>>real_p[assign_a(m_cData.tColor2.fG)]>>
					cSep>>real_p[assign_a(m_cData.tColor2.fB)]>>
					cSep>>real_p[assign_a(m_cData.tColor2.fA)]
					))
					>>*space_p).full;
			if (!bParsed)
				return E_FAIL;
			Unescape(strPatt);
			m_cData.bStock = false;
			for (SPattern const* p = g_aPatterns; p != g_aPatterns+itemsof(g_aPatterns); ++p)
			{
				if (wcscmp(strPatt.c_str(), p->pName) == 0)
				{
					m_cData.bStock = true;
					m_cData.nIndex = p-g_aPatterns;
					break;
				}
			}
			if (!m_cData.bStock)
				m_cData.strPath = strPatt;
			if (cData != m_cData && m_pOwner)
			{
				CComObject<CSharedStateToolData>* pNew = NULL;
				CComObject<CSharedStateToolData>::CreateInstance(&pNew);
				CComPtr<ISharedState> pTmp = pNew;
				if (pNew->Init(m_cData))
				{
					m_pOwner->SetBrushState(pTmp);
				}
			}
			return S_OK;
		}
		catch (...)
		{
			return E_UNEXPECTED;
		}
	}
	STDMETHOD(ToText)(BSTR* a_pbstrParams)
	{
		CComBSTR bstr;
		if (m_cData.bStock)
		{
			wchar_t sz[128];
			swprintf(sz, L"\"%s\", %g, %g, %g, %g, %g, %g, %g, %g", g_aPatterns[m_cData.nIndex].pName, m_cData.tColor1.fR, m_cData.tColor1.fG, m_cData.tColor1.fB, m_cData.tColor1.fA, m_cData.tColor2.fR, m_cData.tColor2.fG, m_cData.tColor2.fB, m_cData.tColor2.fA);
			bstr += sz;
		}
		else
		{
			bstr = L"\"";
			ULONG nExtra = 0;
			if (m_cData.strPath.c_str()) for (LPCWSTR psz = m_cData.strPath.c_str(); *psz; ++psz)
				if (*psz == L'\"' || *psz == L'\\')
					++nExtra;
			if (nExtra)
			{
				CAutoVectorPtr<OLECHAR> sz(new OLECHAR[nExtra+m_cData.strPath.length()+1]);
				LPOLESTR pszD = sz;
				for (LPCWSTR psz = m_cData.strPath.c_str(); *psz; ++psz, ++pszD)
				{
					if (*psz == L'\"' || *psz == L'\\')
						*(pszD++) = L'\\';
					*pszD = *psz;
				}
				*pszD = L'\0';
				bstr += sz.m_p;
			}
			else
			{
				bstr += m_cData.strPath.c_str();
			}
			bstr += L"\"";
		}
		*a_pbstrParams = bstr.Detach();
		return S_OK;
	}

private:
	CComPtr<IRasterImageBrushOwner> m_pOwner;
	CFillStyleDataPattern m_cData;
	std::wstring m_strPatPath;
	ULONG m_nPatSizeX;
	ULONG m_nPatSizeY;
	CAutoVectorPtr<TPixelChannel> m_pPatData;
};

